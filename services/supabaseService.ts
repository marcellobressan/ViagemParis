
import { createClient, type SupabaseClient } from '@supabase/supabase-js';
import type { Comment } from '../types';
import { SUPABASE_URL_PLACEHOLDER, SUPABASE_ANON_KEY_PLACEHOLDER } from '../constants.tsx';

// This is a minimal schema definition based on the usage in the app.
// It makes the Supabase client fully type-safe for comment operations.
type Database = {
  public: {
    Tables: {
      comentarios: {
        Row: {
          id: string;
          author: string;
          text: string;
          created_at: string;
        };
        // The Insert type should only contain fields that are provided by the user,
        // not fields generated by the database like 'id' and 'created_at'.
        Insert: {
          author: string;
          text: string;
        };
        Update: {
          id?: string;
          author?: string;
          text?: string;
          created_at?: string;
        };
        // Relationships should be an empty array if there are no defined relationships.
        // Its absence can cause type inference to fail for insert/update operations.
        Relationships: [];
      };
    };
    Views: { [key: string]: never };
    Functions: { [key: string]: never };
    Enums: { [key: string]: never };
    CompositeTypes: { [key: string]: never };
  }
}

// Supabase credentials are expected to be available in the process.env object.
// This is typically handled by a build tool that replaces these variables
// with their actual values at build time.
const SUPABASE_URL = process.env.SUPABASE_URL || SUPABASE_URL_PLACEHOLDER;
const SUPABASE_ANON_KEY = process.env.SUPABASE_ANON_KEY || SUPABASE_ANON_KEY_PLACEHOLDER;


let supabase: SupabaseClient<Database> | null = null;

if (SUPABASE_URL && SUPABASE_ANON_KEY && SUPABASE_URL !== SUPABASE_URL_PLACEHOLDER && SUPABASE_ANON_KEY !== SUPABASE_ANON_KEY_PLACEHOLDER) {
  try {
    // Initialize the client with the Database generic to ensure full type safety.
    supabase = createClient<Database>(SUPABASE_URL, SUPABASE_ANON_KEY);
  } catch (error) {
    console.error("Error initializing Supabase client:", error);
  }
} else {
  console.warn(
    "Supabase URL or Anon Key not configured or using placeholder values. " +
    "Please set SUPABASE_URL and SUPABASE_ANON_KEY in your environment. " +
    "Comment functionality will be disabled."
  );
}

export const getSupabaseClient = (): SupabaseClient<Database> | null => {
    return supabase;
};

export const isSupabaseAvailable = (): boolean => !!supabase;

export const loadComments = async (): Promise<Comment[]> => {
  if (!supabase) throw new Error("Supabase client not initialized.");
  
  const { data, error } = await supabase
    .from('comentarios')
    .select('*')
    .order('created_at', { ascending: false });

  if (error) {
    console.error('Supabase error loading comments:', error);
    if (error.message.includes('relation "public.comentarios" does not exist')) {
        throw new Error('A tabela "comentarios" n√£o existe na base de dados. Por favor, crie-a no painel do Supabase.');
    }
    throw error;
  }
  // With a correctly typed client, `data` is `Comment[] | null`.
  // A simple truthiness check is sufficient and type-safe.
  return data || [];
};

export const addComment = async (author: string, text: string): Promise<void> => {
  if (!supabase) throw new Error("Supabase client not initialized.");

  // By defining the `Insert` type correctly in the `Database` generic,
  // we no longer need the 'as any' cast, restoring full type safety.
  const { error } = await supabase
    .from('comentarios')
    .insert([{ author, text }]);
  
  if (error) {
    console.error('Supabase error adding comment:', error);
    throw error;
  }
};
